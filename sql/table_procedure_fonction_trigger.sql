CREATE TABLE "APPARTIENTGROUPE" 
   (    "IDUSER" VARCHAR2(100), 
    "NOMGROUPE" VARCHAR2(100), 
     CONSTRAINT "APPARTIENTGROUPE_PK" PRIMARY KEY ("IDUSER", "NOMGROUPE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "APPARTIENTGROUPE" ADD CONSTRAINT "FK_GROUPEUSERS" FOREIGN KEY ("NOMGROUPE")
      REFERENCES "GROUPEUSERS" ("NOMGROUPE") ON DELETE CASCADE ENABLE;
  ALTER TABLE "APPARTIENTGROUPE" ADD CONSTRAINT "FK_USERS" FOREIGN KEY ("IDUSER")
      REFERENCES "USERS" ("idUser") ON DELETE CASCADE ENABLE;

CREATE UNIQUE INDEX "APPARTIENTGROUPE_PK" ON "APPARTIENTGROUPE" ("IDUSER", "NOMGROUPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "AUTEURPROPOSITION" 
   (    "IDAUTEUR" VARCHAR2(100), 
    "IDQUESTION" NUMBER(*,0), 
    "IDPROPOSITION" NUMBER(*,0), 
     CONSTRAINT "AUTEURPROPOSITION_PK" PRIMARY KEY ("IDAUTEUR", "IDQUESTION", "IDPROPOSITION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "AUTEURPROPOSITION" ADD CONSTRAINT "FK_AUTEURS_AUTEURPROP" FOREIGN KEY ("IDAUTEUR", "IDQUESTION")
      REFERENCES "AUTEURS" ("IDVOTANT", "IDQUESTION") ON DELETE CASCADE ENABLE;
  ALTER TABLE "AUTEURPROPOSITION" ADD CONSTRAINT "FK_IDPROPOSITION_AUTEURPROP" FOREIGN KEY ("IDPROPOSITION")
      REFERENCES "PROPOSITIONS" ("IDPROPOSITION") ON DELETE CASCADE ENABLE;

CREATE UNIQUE INDEX "AUTEURPROPOSITION_PK" ON "AUTEURPROPOSITION" ("IDAUTEUR", "IDQUESTION", "IDPROPOSITION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "AUTEURS" 
   (    "IDVOTANT" VARCHAR2(100), 
    "IDQUESTION" NUMBER(*,0), 
     CONSTRAINT "AUTEURS_PK" PRIMARY KEY ("IDVOTANT", "IDQUESTION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "AUTEURS" ADD CONSTRAINT "FK_VOTANTS" FOREIGN KEY ("IDVOTANT", "IDQUESTION")
      REFERENCES "VOTANTS" ("IDUSER", "IDQUESTION") ON DELETE CASCADE ENABLE;

CREATE UNIQUE INDEX "AUTEURS_PK" ON "AUTEURS" ("IDVOTANT", "IDQUESTION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "COMMENTAIRES" 
   (    "IDPROPOSITION" NUMBER(*,0), 
    "IDUSER" VARCHAR2(100), 
    "TEXTE" VARCHAR2(140), 
    "DATECOMMENTAIRE" DATE, 
    "NBLIKE" NUMBER(*,0), 
    "IDCOMMENTAIRE" NUMBER(*,0), 
     CONSTRAINT "COMMENTAIRES_PK" PRIMARY KEY ("IDCOMMENTAIRE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "COMMENTAIRES" ADD CONSTRAINT "FK_idProposition_Commentaires" FOREIGN KEY ("IDPROPOSITION")
      REFERENCES "PROPOSITIONS" ("IDPROPOSITION") ON DELETE CASCADE ENABLE;
  ALTER TABLE "COMMENTAIRES" ADD CONSTRAINT "FK_idUser_Commentaires" FOREIGN KEY ("IDUSER")
      REFERENCES "USERS" ("idUser") ON DELETE CASCADE ENABLE;

CREATE OR REPLACE TRIGGER "AUTO_INCREMENT_COMMENTAIRES" BEFORE INSERT
ON commentaires FOR EACH ROW 
BEGIN
    SELECT commentaires_seq.NEXTVAL into :NEW.idCommentaire FROM DUAL;
END;
/
ALTER TRIGGER "AUTO_INCREMENT_COMMENTAIRES" ENABLE;

CREATE UNIQUE INDEX "COMMENTAIRES_PK" ON "COMMENTAIRES" ("IDCOMMENTAIRE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "DEMANDEAUTEUR" 
   (    "IDUSER" VARCHAR2(100), 
    "IDPROPOSITION" NUMBER(*,0), 
     CONSTRAINT "DEMANDEAUTEUR_PK" PRIMARY KEY ("IDUSER", "IDPROPOSITION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "DEMANDEAUTEUR" ADD CONSTRAINT "FK_IDUSER_DEMANDEAUTEUR" FOREIGN KEY ("IDUSER")
      REFERENCES "USERS" ("idUser") ON DELETE CASCADE ENABLE;
  ALTER TABLE "DEMANDEAUTEUR" ADD CONSTRAINT "FK_idProposition_DemandeAuteur" FOREIGN KEY ("IDPROPOSITION")
      REFERENCES "PROPOSITIONS" ("IDPROPOSITION") ON DELETE CASCADE ENABLE;

CREATE UNIQUE INDEX "DEMANDEAUTEUR_PK" ON "DEMANDEAUTEUR" ("IDUSER", "IDPROPOSITION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "DEMANDERESPONSABLE" 
   (    "IDUSER" VARCHAR2(100), 
    "IDQUESTION" NUMBER(*,0), 
     CONSTRAINT "DEMANDERESPONSABLE_PK" PRIMARY KEY ("IDUSER", "IDQUESTION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "DEMANDERESPONSABLE" ADD CONSTRAINT "FK_idQuestion_demandeResp" FOREIGN KEY ("IDQUESTION")
      REFERENCES "QUESTIONS" ("IDQUESTION") ON DELETE CASCADE ENABLE;
  ALTER TABLE "DEMANDERESPONSABLE" ADD CONSTRAINT "FK_idUser_demandeResp" FOREIGN KEY ("IDUSER")
      REFERENCES "USERS" ("idUser") ON DELETE CASCADE ENABLE;

CREATE UNIQUE INDEX "DEMANDERESPONSABLE_PK" ON "DEMANDERESPONSABLE" ("IDUSER", "IDQUESTION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "DEMANDEVOTANT" 
   (    "IDUSER" VARCHAR2(100), 
    "IDQUESTION" NUMBER(*,0), 
     CONSTRAINT "DEMMANDEVOTANT_PK" PRIMARY KEY ("IDUSER", "IDQUESTION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "DEMANDEVOTANT" ADD CONSTRAINT "FK_idQuestion_DemmandeVotant" FOREIGN KEY ("IDQUESTION")
      REFERENCES "QUESTIONS" ("IDQUESTION") ON DELETE CASCADE ENABLE;
  ALTER TABLE "DEMANDEVOTANT" ADD CONSTRAINT "FK_idUser_demmandeVotant" FOREIGN KEY ("IDUSER")
      REFERENCES "USERS" ("idUser") ON DELETE CASCADE ENABLE;

CREATE UNIQUE INDEX "DEMMANDEVOTANT_PK" ON "DEMANDEVOTANT" ("IDUSER", "IDQUESTION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "EMAILUSERSINVALIDE" 
   (    "IDUSER" VARCHAR2(100), 
    "NONCE" NUMBER, 
     CONSTRAINT "EMAILUSERSINVALIDE_PK" PRIMARY KEY ("IDUSER")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "EMAILUSERSINVALIDE" ADD CONSTRAINT "FK_idUser_EmailUserInvalide" FOREIGN KEY ("IDUSER")
      REFERENCES "USERS" ("idUser") ON DELETE CASCADE ENABLE;

CREATE UNIQUE INDEX "EMAILUSERSINVALIDE_PK" ON "EMAILUSERSINVALIDE" ("IDUSER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "GROUPEUSERS" 
   (    "NOMGROUPE" VARCHAR2(100), 
    "IDUSERRESPONSABLE" VARCHAR2(100), 
     CONSTRAINT "GROUPEUSERS_PK" PRIMARY KEY ("NOMGROUPE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "GROUPEUSERS" ADD CONSTRAINT "FK_idResponsable_GroupeUsers" FOREIGN KEY ("IDUSERRESPONSABLE")
      REFERENCES "USERS" ("idUser") ON DELETE CASCADE ENABLE;

CREATE OR REPLACE TRIGGER "INCLUSION_INSERT_GROUPE_RESP" 
AFTER INSERT ON groupeUsers FOR EACH ROW
DECLARE
    v_verif NUMBER;
BEGIN
    SELECT count(:NEW.IDUSERRESPONSABLE) INTO v_verif
    FROM dual WHERE :NEW.IDUSERRESPONSABLE IS NOT NULL;
    if(v_verif>0) THEN
        INSERT INTO APPARTIENTGROUPE(idUser, nomGroupe)
        values(:NEW.idUserResponsable, :NEW.NOMGROUPE);
    END IF;
END;
/
ALTER TRIGGER "INCLUSION_INSERT_GROUPE_RESP" ENABLE;
  CREATE OR REPLACE TRIGGER "INCLUSION_UPDATE_GROUPE_RESP" 
BEFORE UPDATE ON groupeUsers FOR EACH ROW
DECLARE
    v_verif NUMBER;
BEGIN
    SELECT count(idUser) INTO v_verif
    FROM APPARTIENTGROUPE a
    WHERE a.IDUSER = :NEW.idUserResponsable AND a.NOMGROUPE = :NEW.nomGroupe;
    if(v_verif=0) THEN
        raise_application_error(-2015, 'l''user désigné comme responsable n''apartient pas au groupe');
    END IF;
END;


/
ALTER TRIGGER "INCLUSION_UPDATE_GROUPE_RESP" ENABLE;

CREATE UNIQUE INDEX "GROUPEUSERS_PK" ON "GROUPEUSERS" ("NOMGROUPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "INTERACTIONCOMMENTAIRE" 
   (    "IDUSER" VARCHAR2(100), 
    "IDCOMMENTAIRE" NUMBER(*,0), 
    "IDPROPOSITION" NUMBER(*,0), 
    "VALEURINTERACTION" NUMBER(*,0), 
     CONSTRAINT "INTERACTIONCOMMENTAIRE_PK" PRIMARY KEY ("IDPROPOSITION", "IDCOMMENTAIRE", "IDUSER")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "ANNEE2" ;

ALTER TABLE "INTERACTIONCOMMENTAIRE" ADD CONSTRAINT "FK_IDCOMMENTAIRE_INTERACTCOMM" FOREIGN KEY ("IDCOMMENTAIRE")
      REFERENCES "COMMENTAIRES" ("IDCOMMENTAIRE") ON DELETE CASCADE ENABLE;
  ALTER TABLE "INTERACTIONCOMMENTAIRE" ADD CONSTRAINT "FK_IDPROPOSITION_INTERACTCOMM" FOREIGN KEY ("IDPROPOSITION")
      REFERENCES "PROPOSITIONS" ("IDPROPOSITION") ON DELETE CASCADE ENABLE;
  ALTER TABLE "INTERACTIONCOMMENTAIRE" ADD CONSTRAINT "FK_IDUSER_INTERACTCOMM" FOREIGN KEY ("IDUSER")
      REFERENCES "USERS" ("idUser") ON DELETE CASCADE ENABLE;

CREATE UNIQUE INDEX "INTERACTIONCOMMENTAIRE_PK" ON "INTERACTIONCOMMENTAIRE" ("IDPROPOSITION", "IDCOMMENTAIRE", "IDUSER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "ANNEE2" ;

CREATE TABLE "LIKESSECTIONS" 
   (    "IDSECTION" NUMBER(*,0), 
    "IDUSER" VARCHAR2(100), 
    "IDPROPOSITION" NUMBER(*,0), 
     CONSTRAINT "LIKESSECTIONS_PK" PRIMARY KEY ("IDSECTION", "IDUSER", "IDPROPOSITION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "LIKESSECTIONS" ADD CONSTRAINT "FK_idProposition_likesSection" FOREIGN KEY ("IDPROPOSITION")
      REFERENCES "PROPOSITIONS" ("IDPROPOSITION") ON DELETE CASCADE ENABLE;
  ALTER TABLE "LIKESSECTIONS" ADD CONSTRAINT "FK_idSection_likesSections" FOREIGN KEY ("IDSECTION")
      REFERENCES "SECTIONS" ("IDSECTION") ON DELETE CASCADE ENABLE;
  ALTER TABLE "LIKESSECTIONS" ADD CONSTRAINT "FK_idUser_likesSections" FOREIGN KEY ("IDUSER")
      REFERENCES "USERS" ("idUser") ON DELETE CASCADE ENABLE;

CREATE UNIQUE INDEX "LIKESSECTIONS_PK" ON "LIKESSECTIONS" ("IDSECTION", "IDUSER", "IDPROPOSITION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "PHASES" 
   (    "IDPHASE" NUMBER(*,0), 
    "DATEDEBUT" DATE, 
    "DATEFIN" DATE, 
    "TYPEPHASE" VARCHAR2(100), 
    "IDQUESTIONCONCERNE" NUMBER(*,0), 
     CONSTRAINT "PHASES_PK" PRIMARY KEY ("IDPHASE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "PHASES" ADD CONSTRAINT "FK_idQuestion_Phases" FOREIGN KEY ("IDQUESTIONCONCERNE")
      REFERENCES "QUESTIONS" ("IDQUESTION") ON DELETE CASCADE ENABLE;

CREATE OR REPLACE TRIGGER "AUTOINCREMENTPHASES" 
BEFORE INSERT ON PHASES
FOR EACH ROW
BEGIN
    SELECT phases_seq.NEXTVAL into :NEW.idPhase FROM DUAL;
END;
/
ALTER TRIGGER "AUTOINCREMENTPHASES" ENABLE;
  CREATE OR REPLACE TRIGGER "DATESPHASEQUESTION" BEFORE INSERT ON PHASES FOR EACH ROW
DECLARE
    v_verif NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_verif
    FROM QUESTIONS q
    WHERE :NEW.dateDebut >= q.dateCreation AND :NEW.dateFin <= q.dateFermeture
    AND q.idQuestion = :NEW.IDQUESTIONCONCERNE;
    if(v_verif = 0) then
        raise_application_error(-20021, 'les dates de la phase dépassent la période dans laquelle se déroule la question');
    end if;
END;
/
ALTER TRIGGER "DATESPHASEQUESTION" ENABLE;
  CREATE OR REPLACE TRIGGER "MODIFDATEPHASE" 
BEFORE UPDATE ON PHASES FOR EACH ROW
DECLARE
    v_dateFinQuestion DATE;
BEGIN
    -- empeche une phase de finir apres sa question
    SELECT dateFermeture INTO v_dateFinQuestion
    FROM QUESTIONS
    WHERE idQuestion=:NEW.idQuestionConcerne;
    --IF :NEW.dateFin > v_dateFinQuestion THEN
        --:NEW.dateFin := v_dateFinQuestion;
    --END IF;
END;
/
ALTER TRIGGER "MODIFDATEPHASE" ENABLE;

CREATE UNIQUE INDEX "PHASES_PK" ON "PHASES" ("IDPHASE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "PHASESVOTE" 
   (    "IDPHASE" NUMBER(*,0), 
    "NBDEPLACES" NUMBER(38,0) NOT NULL ENABLE, 
     CONSTRAINT "PHASESVOTE_PK" PRIMARY KEY ("IDPHASE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "PHASESVOTE" ADD CONSTRAINT "FK_idPhase_PhasesVote" FOREIGN KEY ("IDPHASE")
      REFERENCES "PHASES" ("IDPHASE") ON DELETE CASCADE ENABLE;

CREATE UNIQUE INDEX "PHASESVOTE_PK" ON "PHASESVOTE" ("IDPHASE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "PROPOSERTEXTE" 
   (    "IDPROPOSITION" NUMBER(*,0) NOT NULL ENABLE, 
    "IDSECTION" NUMBER(*,0) NOT NULL ENABLE, 
    "TEXTE" VARCHAR2(1000), 
     CONSTRAINT "PROPOSERTEXTE_PK" PRIMARY KEY ("IDPROPOSITION", "IDSECTION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "PROPOSERTEXTE" ADD CONSTRAINT "FK_idPROPOSITION_ProposerTexte" FOREIGN KEY ("IDPROPOSITION")
      REFERENCES "PROPOSITIONS" ("IDPROPOSITION") ON DELETE CASCADE ENABLE;
  ALTER TABLE "PROPOSERTEXTE" ADD CONSTRAINT "FK_idSection_PROPOSERTEXTE" FOREIGN KEY ("IDSECTION")
      REFERENCES "SECTIONS" ("IDSECTION") ENABLE;

CREATE OR REPLACE TRIGGER "TEXTEPROPOSITIONSECTION" 
BEFORE INSERT ON PROPOSERTEXTE FOR EACH ROW
DECLARE
    v_verification INTEGER;
BEGIN
    SELECT COUNT(q.idQuestion) INTO v_verification
    FROM SOUVIGNETN.PROPOSITIONS p
    JOIN SOUVIGNETN.QUESTIONS q ON p.idQuestion = q.idQuestion
    JOIN SOUVIGNETN.SECTIONS s ON s.IDQUESTION = q.IDQUESTION
    WHERE s.IDSECTION = :NEW.idSection
    AND p.IDPROPOSITION = :NEW.idProposition;
    IF (v_verification = 0) THEN
        RAISE_APPLICATION_ERROR(-20010, 'la section à laquelle répond le texte n''appartient pas à la question à laquelle la proposition répond');
    END IF;
END;
/
ALTER TRIGGER "TEXTEPROPOSITIONSECTION" ENABLE;

CREATE UNIQUE INDEX "PROPOSERTEXTE_PK" ON "PROPOSERTEXTE" ("IDPROPOSITION", "IDSECTION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "PROPOSITIONS" 
   (    "IDPROPOSITION" NUMBER(*,0) NOT NULL ENABLE, 
    "IDQUESTION" NUMBER(*,0) NOT NULL ENABLE, 
    "INTITULE" VARCHAR2(100), 
    "ARCHIVE" VARCHAR2(1) DEFAULT 'F' NOT NULL ENABLE, 
    "IDRESPONSABLE" VARCHAR2(100) DEFAULT 'souvignetn', 
    "VISIBLE" VARCHAR2(1) DEFAULT 'F', 
     CONSTRAINT "PROPOSITIONS_PK" PRIMARY KEY ("IDPROPOSITION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "PROPOSITIONS" ADD CONSTRAINT "FK_RESPONSABLES_Propositions" FOREIGN KEY ("IDQUESTION", "IDRESPONSABLE")
      REFERENCES "RESPONSABLES" ("IDQUESTION", "IDAUTEUR") ON DELETE CASCADE ENABLE;
  ALTER TABLE "PROPOSITIONS" ADD CONSTRAINT "FK_idQUESTION_Propositions" FOREIGN KEY ("IDQUESTION")
      REFERENCES "QUESTIONS" ("IDQUESTION") ON DELETE CASCADE ENABLE;

CREATE OR REPLACE TRIGGER "AUTOINCREMENTPROPOSITIONS" 
BEFORE INSERT ON PROPOSITIONS FOR EACH ROW
BEGIN
    SELECT propositions_seq.NEXTVAL into :NEW.idProposition FROM DUAL;
END;
/
ALTER TRIGGER "AUTOINCREMENTPROPOSITIONS" ENABLE;
  CREATE OR REPLACE TRIGGER "INCLUSION_AUTEUR_RESPPROPAL" 
BEFORE UPDATE ON PROPOSITIONS FOR EACH ROW
DECLARE
    v_verif NUMBER;
BEGIN
    SELECT count(idAuteur) INTO v_verif
    FROM auteurProposition
    WHERE idAuteur=:NEW.idResponsable AND idProposition=:NEW.idProposition;
    if(v_verif=0) THEN
        raise_application_error(-20016, 'le responsable de la proposition ne fait pas parti du groupe de rédaction');
    END IF;
END;
/
ALTER TRIGGER "INCLUSION_AUTEUR_RESPPROPAL" ENABLE;
  CREATE OR REPLACE TRIGGER "INSERTIONRESPPROPAL" 
AFTER INSERT ON propositions FOR EACH ROW
BEGIN 
    INSERT INTO AUTEURPROPOSITION(idAuteur, idQuestion, IDPROPOSITION)
    VALUES(:NEW.idResponsable, :NEW.idQuestion, :NEW.idProposition);
END;
/
ALTER TRIGGER "INSERTIONRESPPROPAL" ENABLE;

CREATE UNIQUE INDEX "PROPOSITIONS_PK" ON "PROPOSITIONS" ("IDPROPOSITION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "QUESTIONS" 
   (    "IDQUESTION" NUMBER(*,0) NOT NULL ENABLE, 
    "INTITULEQUESTION" VARCHAR2(100) NOT NULL ENABLE, 
    "DESCRIPTIONQUESTION" VARCHAR2(1000), 
    "DATECREATION" DATE, 
    "DATEFERMETURE" DATE, 
    "TYPEPHASE" VARCHAR2(100), 
    "IDCURRENTPHASE" NUMBER(*,0), 
    "IDORGANISATEUR" VARCHAR2(100), 
     CONSTRAINT "QUESTIONS_PK" PRIMARY KEY ("IDQUESTION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "QUESTIONS" ADD CONSTRAINT "FK_idCurrentPhase_Questions" FOREIGN KEY ("IDCURRENTPHASE")
      REFERENCES "PHASES" ("IDPHASE") ENABLE;
  ALTER TABLE "QUESTIONS" ADD CONSTRAINT "FK_idOrganisateur_Questions" FOREIGN KEY ("IDORGANISATEUR")
      REFERENCES "USERS" ("idUser") ON DELETE CASCADE ENABLE;

CREATE OR REPLACE TRIGGER "AUTOINCREMENTQUESTIONS" 
BEFORE INSERT ON QUESTIONS FOR EACH ROW
BEGIN
    SELECT questions_seq.NEXTVAL INTO :NEW.idQuestion FROM dual;
END;
/
ALTER TRIGGER "AUTOINCREMENTQUESTIONS" ENABLE;
  CREATE OR REPLACE TRIGGER "INCLUSIONORGAVOTANT" 
AFTER INSERT ON QUESTIONS FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('idOrga: ' || :NEW.idOrganisateur || ' idQuestion: ' || :NEW.idQuestion);
    setRoleQuestion(:NEW.idOrganisateur, 'responsable', :NEW.idQuestion);
END;
/
ALTER TRIGGER "INCLUSIONORGAVOTANT" ENABLE;

CREATE UNIQUE INDEX "QUESTIONS_PK" ON "QUESTIONS" ("IDQUESTION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "RESPONSABLES" 
   (    "IDQUESTION" NUMBER(*,0), 
    "IDAUTEUR" VARCHAR2(100), 
     CONSTRAINT "RESPONSABLES_PK" PRIMARY KEY ("IDQUESTION", "IDAUTEUR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "RESPONSABLES" ADD CONSTRAINT "FK_AUTEURS" FOREIGN KEY ("IDAUTEUR", "IDQUESTION")
      REFERENCES "AUTEURS" ("IDVOTANT", "IDQUESTION") ON DELETE CASCADE ENABLE;

CREATE UNIQUE INDEX "RESPONSABLES_PK" ON "RESPONSABLES" ("IDQUESTION", "IDAUTEUR") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "SECTIONS" 
   (    "IDSECTION" NUMBER(*,0), 
    "IDQUESTION" NUMBER(*,0), 
    "INTITULESECTION" VARCHAR2(200), 
    "DESCRIPTIONSECTION" VARCHAR2(1000), 
     CONSTRAINT "SECTIONS_PK" PRIMARY KEY ("IDSECTION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "SECTIONS" ADD CONSTRAINT "FK_idQuestion_Sections" FOREIGN KEY ("IDQUESTION")
      REFERENCES "QUESTIONS" ("IDQUESTION") ON DELETE CASCADE ENABLE;

CREATE OR REPLACE TRIGGER "AUTOINCREMENTSECTIONS" 
BEFORE INSERT ON SECTIONS FOR EACH ROW
BEGIN
    SELECT sections_seq.NEXTVAL INTO :NEW.idSection FROM dual;
END;
/
ALTER TRIGGER "AUTOINCREMENTSECTIONS" ENABLE;
  CREATE OR REPLACE TRIGGER "NONULLSECTIONS" 
BEFORE UPDATE ON SECTIONS FOR EACH ROW
BEGIN
    if(:new.intituleSection IS NULL) then
        :new.intituleSection := 'intitulé';
    end if;
    if(:new.descriptionSection IS NULL)then
        :new.descriptionSection := 'description';
    end if;
end;
/
ALTER TRIGGER "NONULLSECTIONS" ENABLE;

CREATE UNIQUE INDEX "SECTIONS_PK" ON "SECTIONS" ("IDSECTION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "SESSIONVOTE" 
   (    "IDQUESTION" NUMBER(*,0), 
    "IDPHASEVOTE" NUMBER(*,0), 
    "IDPROPOSITION" NUMBER(*,0), 
    "SCORE" NUMBER(*,0) DEFAULT 0, 
     CONSTRAINT "SESSIONVOTE_PK" PRIMARY KEY ("IDQUESTION", "IDPHASEVOTE", "IDPROPOSITION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "SESSIONVOTE" ADD CONSTRAINT "FK_idProposition_sessionVote" FOREIGN KEY ("IDPROPOSITION")
      REFERENCES "PROPOSITIONS" ("IDPROPOSITION") ON DELETE CASCADE ENABLE;

CREATE OR REPLACE TRIGGER "INCLUSION_SESSIONVOTE" 
BEFORE INSERT ON SESSIONVOTE
FOR EACH ROW
DECLARE
    v_verif INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_verif
    FROM PROPOSITIONS p
    WHERE p.idProposition = :NEW.idProposition
    AND p.idQuestion = :NEW.idQuestion
    AND p.ARCHIVE = 'F';
    if(v_verif=0) then
        raise_application_error(-20012, 'la proposition n''est pas associé à la question ou elle est archivé');
    end if;
end;
/
ALTER TRIGGER "INCLUSION_SESSIONVOTE" ENABLE;
  CREATE OR REPLACE TRIGGER "ZERODANSSESSION" BEFORE INSERT ON SESSIONVOTE FOR EACH ROW
BEGIN
    IF :NEW.SCORE IS NULL THEN
        :NEW.SCORE := 0;
    END IF;
    dbms_output.put_line('score: ' || :NEW.SCORE);
END;
/
ALTER TRIGGER "ZERODANSSESSION" ENABLE;

CREATE UNIQUE INDEX "SESSIONVOTE_PK" ON "SESSIONVOTE" ("IDQUESTION", "IDPHASEVOTE", "IDPROPOSITION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "USERS" 
   (    "idUser" VARCHAR2(100) NOT NULL ENABLE, 
    "MDP" VARCHAR2(256), 
    "PRENOMUSER" VARCHAR2(100), 
    "NOMUSER" VARCHAR2(100), 
    "role" VARCHAR2(100), 
    "EMAIL" VARCHAR2(50), 
     CONSTRAINT "COMPTES_PK" PRIMARY KEY ("idUser")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE OR REPLACE TRIGGER "TR_USERAVALIDER" 
AFTER INSERT ON SOUVIGNETN.USERS
FOR EACH ROW
BEGIN
    INSERT INTO SOUVIGNETN.EMAILUSERSINVALIDE(IDUSER) VALUES(:NEW."idUser");
END;
/
ALTER TRIGGER "TR_USERAVALIDER" ENABLE;

CREATE UNIQUE INDEX "COMPTES_PK" ON "USERS" ("idUser") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "VOTANTPROPOSITION" 
   (    "IDVOTANT" VARCHAR2(100), 
    "IDPROPOSITION" NUMBER(*,0), 
    "IDPHASEVOTE" NUMBER(*,0), 
    "SCOREVOTE" NUMBER(38,0) DEFAULT 0 NOT NULL ENABLE, 
    "IDQUESTION" NUMBER(*,0) NOT NULL ENABLE, 
     CONSTRAINT "VOTANTPROPOSITION_PK" PRIMARY KEY ("IDVOTANT", "IDQUESTION", "IDPHASEVOTE", "IDPROPOSITION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "VOTANTPROPOSITION" ADD CONSTRAINT "FK_SESSIONVOTE_VotantPropal" FOREIGN KEY ("IDQUESTION", "IDPHASEVOTE", "IDPROPOSITION")
      REFERENCES "SESSIONVOTE" ("IDQUESTION", "IDPHASEVOTE", "IDPROPOSITION") ON DELETE CASCADE ENABLE;
  ALTER TABLE "VOTANTPROPOSITION" ADD CONSTRAINT "FK_idPhaseVote_VotantPropal" FOREIGN KEY ("IDPHASEVOTE")
      REFERENCES "PHASESVOTE" ("IDPHASE") ON DELETE CASCADE ENABLE;
  ALTER TABLE "VOTANTPROPOSITION" ADD CONSTRAINT "FK_idProposition_VotantPropal" FOREIGN KEY ("IDPROPOSITION")
      REFERENCES "PROPOSITIONS" ("IDPROPOSITION") ON DELETE CASCADE ENABLE;
  ALTER TABLE "VOTANTPROPOSITION" ADD CONSTRAINT "FK_idVotant_VotantProposition" FOREIGN KEY ("IDVOTANT", "IDQUESTION")
      REFERENCES "VOTANTS" ("IDUSER", "IDQUESTION") ON DELETE CASCADE ENABLE;

CREATE OR REPLACE TRIGGER "INCLUSION_VOTANTPROPOSITION" BEFORE INSERT OR UPDATE ON VOTANTPROPOSITION FOR EACH ROW
DECLARE
    v_verif NUMBER;
BEGIN
    SELECT COUNT(idProposition) INTO v_verif
    FROM SESSIONVOTE
    WHERE idProposition=:NEW.idProposition AND idPhaseVote=:NEW.idPhaseVote;
    if v_verif=0 THEN
        raise_application_error(-20023, 'contrainte d''inclusion VotantProposition non respecté');
    END IF;
END;
/
ALTER TRIGGER "INCLUSION_VOTANTPROPOSITION" ENABLE;
  CREATE OR REPLACE TRIGGER "UPDATESCORE" BEFORE UPDATE OR INSERT ON VOTANTPROPOSITION FOR EACH ROW
DECLARE
    v_typePhase VARCHAR2(30);
BEGIN
    SELECT typePhase INTO v_typePhase
    FROM PHASES p 
    WHERE idPhase=:NEW.idPhaseVote;
    
    IF v_typePhase != 'jugementMajoritaire' THEN
        IF INSERTING THEN
            UPDATE SESSIONVOTE sv set score = score + :NEW.SCOREVOTE WHERE sv.idProposition=:NEW.idProposition AND sv.idPhaseVote=:NEW.idPhaseVote AND sv.idQuestion=:NEW.idQuestion;
        ELSE
            UPDATE SESSIONVOTE sv set score = score-:OLD.SCOREVOTE WHERE sv.idProposition=:OLD.idProposition AND sv.idPhaseVote=:OLD.idPhaseVote AND sv.idQuestion=:OLD.idQuestion;
            UPDATE SESSIONVOTE sv set score = score+:NEW.SCOREVOTE WHERE sv.idProposition=:NEW.idProposition AND sv.idPhaseVote=:NEW.idPhaseVote AND sv.idQuestion=:NEW.idQuestion;
        END IF;
    END IF;
END;
/
ALTER TRIGGER "UPDATESCORE" ENABLE;

CREATE UNIQUE INDEX "VOTANTPROPOSITION_PK" ON "VOTANTPROPOSITION" ("IDVOTANT", "IDQUESTION", "IDPHASEVOTE", "IDPROPOSITION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE TABLE "VOTANTS" 
   (    "IDUSER" VARCHAR2(100), 
    "IDQUESTION" NUMBER(*,0), 
     CONSTRAINT "VOTANTS_PK" PRIMARY KEY ("IDUSER", "IDQUESTION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

ALTER TABLE "VOTANTS" ADD CONSTRAINT "FK_idQuestion_Votants" FOREIGN KEY ("IDQUESTION")
      REFERENCES "QUESTIONS" ("IDQUESTION") ON DELETE CASCADE ENABLE;
  ALTER TABLE "VOTANTS" ADD CONSTRAINT "FK_idUser_Votants" FOREIGN KEY ("IDUSER")
      REFERENCES "USERS" ("idUser") ON DELETE CASCADE ENABLE;

CREATE OR REPLACE TRIGGER "INSERTUSERPENDANTVOTE" 
AFTER INSERT ON VOTANTS FOR EACH ROW
DECLARE
    v_typePhase VARCHAR2(30);
    v_idPhase INTEGER;
    v_nbPropositions INTEGER;
    CURSOR curs_proposition(p_idPhase IN PHASESVOTE.idPhase%TYPE) IS
        SELECT DISTINCT idProposition, typePhase
        FROM SESSIONVOTE s
        JOIN PHASES p ON p.IDPHASE = s.IDPHASEVOTE
        WHERE IDPHASEVOTE = p_idPhase;
BEGIN
    SELECT getIdPhase(:NEW.idQuestion) INTO v_idPhase 
    FROM DUAL;

    FOR proposition IN curs_proposition(v_idPhase) LOOP
        IF(proposition.typePhase='jugementMajoritaire') OR (proposition.typePhase='scrutinMajoritairePlurinominal') THEN
            INSERT INTO VOTANTPROPOSITION(idVotant, idQuestion, IDPHASEVOTE, IDPROPOSITION, SCOREVOTE)
            VALUES (:NEW.idUser, :NEW.idQuestion, v_idPhase, proposition.idProposition, 0);
        END IF;
    END LOOP;
END;
/
ALTER TRIGGER "INSERTUSERPENDANTVOTE" ENABLE;

CREATE UNIQUE INDEX "VOTANTS_PK" ON "VOTANTS" ("IDUSER", "IDQUESTION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "ANNEE2" ;

CREATE OR REPLACE FORCE VIEW "VIEW_DEMANDES" ("IDQUESTION", "IDUSER", "ROLE", "IDPROPOSITION") AS 
  SELECT idQuestion, idUser, 'votant', NULL
FROM DEMANDEVOTANT
UNION
SELECT idQuestion, idUser, 'auteur', p.idProposition
FROM DEMANDEAUTEUR d
JOIN PROPOSITIONS p ON p.IDPROPOSITION=d.IDPROPOSITION
UNION
SELECT idQuestion, idUser, 'responsable', NULL
FROM DEMANDERESPONSABLE;

CREATE OR REPLACE TRIGGER "SUPPRESSIONDEMANDE" 
INSTEAD OF DELETE ON VIEW_DEMANDES FOR EACH ROW
BEGIN 
    IF (:OLD.ROLE = 'votant') THEN
        DELETE FROM DEMANDEVOTANT d
        WHERE IDUSER = :OLD.idUser AND IDQUESTION=:OLD.idQuestion;
    ELSIF (:OLD.ROLE = 'responsable') THEN
        DELETE FROM DEMANDERESPONSABLE d2
        WHERE IDUSER = :OLD.idUser AND IDQUESTION = :OLD.idQuestion;
    ELSE
        DELETE FROM DEMANDEAUTEUR d3
        WHERE IDUSER = :OLD.idUser AND IDPROPOSITION=:OLD.IDPROPOSITION;
    END IF;
END;
/
ALTER TRIGGER "SUPPRESSIONDEMANDE" ENABLE;

CREATE OR REPLACE FORCE VIEW "VUE_PHASESDETAIL" ("IDPHASE", "IDQUESTION", "DATEDEBUT", "DATEFIN", "TYPEPHASE", "NBDEPLACES") AS 
  select p.idPhase, idQuestionConcerne, dateDebut, dateFin, typePhase, nbDePlaces
from Phases p
LEFT JOIN PHASESVOTE p2 ON p.IDPHASE = p2.IDPHASE;

CREATE OR REPLACE TRIGGER "TRIGGER_VUEPHASEVOTE" INSTEAD OF INSERT OR UPDATE ON vue_PhasesDetail FOR EACH ROW
DECLARE 
    v_idPhase Phases.idPhase%TYPE;
    v_verif NUMBER;
BEGIN
    IF (INSERTING) THEN
        INSERT INTO Phases(idQuestionConcerne, DATEDEBUT, DATEFIN, TYPEPHASE)
        VALUES(:NEW.idQuestion, :NEW.dateDebut, :NEW.dateFin, :NEW.TypePhase);
        if(:NEW.TypePhase = 'scrutinMajoritaire' OR :NEW.TypePhase = 'scrutinMajoritairePlurinominal' OR :NEW.TypePhase='jugementMajoritaire') THEN
            SELECT phases_seq.CURRVAL INTO v_idPhase FROM DUAL;
            INSERT INTO PHASESVOTE(idPhase, nbDePlaces)
            VALUES(v_idPhase, :NEW.nbDePlaces);
        END IF;
    ELSE
        UPDATE PHASES SET dateDebut = :NEW.dateDebut, dateFin = :NEW.dateFin, typePhase = :NEW.typePhase WHERE idPhase=:NEW.idPhase;
        -- permettra de savoir si la phase est une phase de vote
        SELECT COUNT(idPhase) INTO v_verif FROM PHASESVOTE WHERE idPhase=:NEW.idPhase;
        -- la phase précédente n'etait pas une phase de vote alors que mtn si
        IF ((:NEW.TypePhase = 'scrutinMajoritaire' OR :NEW.TypePhase = 'scrutinMajoritairePlurinominal' OR :NEW.TypePhase = 'jugementMajoritaire') AND v_verif = 0) THEN
            INSERT INTO PHASESVOTE(idPhase, nbDePlaces)
            VALUES(:NEW.idPhase, :NEW.nbDePlaces);
        -- la phase précédente était une phase de vote, ce qui n'est plus le cas
        ELSIF ((:NEW.TypePhase != 'scrutinMajoritaire' AND :NEW.TypePhase != 'scrutinMajoritairePlurinominal' AND :NEW.TypePhase != 'jugementMajoritaire') AND v_verif = 1) THEN
            DELETE FROM PHASESVOTE WHERE IDPHASE=:NEW.idPhase;
        END IF;
        
        IF v_verif>0 THEN
            UPDATE PHASESVOTE SET NBDEPLACES = :NEW.nbDePlaces WHERE IDPHASE = :NEW.idPhase;
        END IF;
    END IF;
END;
/
ALTER TRIGGER "TRIGGER_VUEPHASEVOTE" ENABLE;

CREATE OR REPLACE PROCEDURE SOUVIGNETN.creerProposition(p_idQuestion IN QUESTIONS.idQuestion%TYPE, p_idResponsable IN VOTANTS.IDUSER%TYPE)
is
    v_idP NUMBER;
BEGIN
    INSERT INTO PROPOSITIONS(idQuestion, IDRESPONSABLE) values(p_idQuestion, p_idResponsable);
    select propositions_seq.CURRVAL INTO v_idP FROM DUAL;
    creerSectionReponse(v_idP);
END;

CREATE OR REPLACE PROCEDURE SOUVIGNETN.CREERQUESTION(p_idOrganisateur IN USERS."idUser"%TYPE, p_Intitule IN QUESTIONS.intituleQuestion%TYPE, p_Description IN QUESTIONS.DescriptionQuestion%TYPE, p_dateCreation IN QUESTIONS.datecreation%TYPE, p_dateFermeture IN QUESTIONS.DATEFERMETURE%TYPE, p_nbSection INTEGER, p_nbPhases INTEGER)
IS
    v_idQuestion QUESTIONS.idQuestion%TYPE;
    v_nbIteration NUMBER := 0;
    v_jour INTEGER := 0;
    v_dateFermeture DATE := p_dateFermeture;
BEGIN
    if(p_dateFermeture < sysdate + p_nbPhases) THEN
        v_dateFermeture := sysdate + p_nbPhases;
    END IF;

    INSERT INTO QUESTIONS(idOrganisateur, intituleQuestion, DescriptionQuestion, datecreation, dateFermeture)
    VALUES (p_idOrganisateur, p_Intitule, p_Description, p_dateCreation, v_dateFermeture);

    SELECT questions_seq.CURRVAL INTO v_idQuestion FROM dual;

    WHILE v_nbIteration < p_nbSection LOOP
        INSERT INTO Sections(idQuestion, intituleSection, descriptionSection)
        VALUES (v_idQuestion, 'intitulé', 'description');
        v_nbIteration := v_nbIteration + 1;
    END LOOP;

    v_nbIteration := 1;
    INSERT INTO PHASES(IDQUESTIONCONCERNE, DATEDEBUT, DATEFIN, TYPEPHASE)
    VALUES(v_idQuestion, SYSDATE + 1, SYSDATE + 1, 'redaction');
    WHILE v_nbIteration < p_nbPhases LOOP
        INSERT INTO Phases(IDQUESTIONCONCERNE, dateDebut, dateFin, typePhase)
        VALUES (v_idQuestion, SYSDATE + v_jour + 1, SYSDATE + v_jour + 1, 'jugementMajoritaire');
        v_nbIteration := v_nbIteration + 1;
        v_jour := v_nbIteration;
    END LOOP;
END;

CREATE OR REPLACE PROCEDURE SOUVIGNETN.creerSectionReponse(id_proposition IN PROPOSITIONS.IDPROPOSITION%TYPE)
IS
    CURSOR c_section(p_idQuestion IN QUESTIONS.IDQUESTION%TYPE) IS SELECT * FROM SECTIONS WHERE IDQUESTION = p_idQuestion;
    v_idQuestion QUESTIONS.IDQUESTION%TYPE;
BEGIN
    SELECT idQuestion INTO v_idQuestion
    FROM PROPOSITIONS p
    WHERE IDPROPOSITION = id_proposition;
    FOR s IN c_section(v_idQuestion) LOOP
        INSERT INTO PROPOSERTEXTE(idProposition, idSection, texte) VALUES(id_proposition, s.idSection, 'à remplir');
    END LOOP;
END;

CREATE OR REPLACE procedure SOUVIGNETN.end_Phase(p_idPhase IN Phases.idPhase%TYPE)
IS
    v_vote INTEGER;
    v_nbMax INTEGER;
    v_scoreMax NUMBER;
    v_typePhase VARCHAR2(30);
    v_nbPropalRestant INTEGER; -- pour jugement majoritaire
    v_nbVotantTotal INTEGER;
    v_scoreProp INTEGER;-- utilisé avec curs_proposition pour parcourir le score median des propositions
    v_currentScore INTEGER; -- pour jugement majoritaire
    v_median INTEGER; -- pour jugement majoritaire (indice du score médian)
    v_increment INTEGER; -- pour s'occuper de l'égalité dans jugement majoritaire
    v_direction INTEGER;
    v_idProposition INTEGER;
    v_scorePrecedant INTEGER;
    CURSOR curs_proposition IS
        SELECT IDPROPOSITION
        FROM SESSIONVOTE;
    CURSOR curs_propositionScore(p_score INTEGER) IS
        SELECT IDPROPOSITION
        FROM SESSIONVOTE
        WHERE score=p_score;
BEGIN
    SELECT COUNT(IDPHASE) INTO v_vote FROM PHASESVOTE WHERE IDPHASE = p_idPhase;
    IF v_vote>0 THEN
        SELECT typePhase INTO v_typePhase
        FROM Phases
        WHERE idPhase=p_idPhase;
    
        -- stock le nb de place à prendre à la fin du dépouillement
        SELECT nbDePlaces INTO v_nbMax
        FROM PHASESVOTE pv
        WHERE pv.IDPHASE=p_idPhase;
        
        IF v_typePhase!='jugementMajoritaire' THEN
            -- dépouillement si c'est un scrutin majoritaire ou un scrutin majoritaire plurinominal
    
            UPDATE PROPOSITIONS SET archive='V' WHERE idQuestion=(SELECT idQuestion FROM PHASES WHERE idPhase=p_idPhase);
    
            WHILE v_nbMax>0 LOOP
                dbms_output.put_line('ahhaha');
                SELECT MAX(score) INTO v_scoreMax
                FROM SESSIONVOTE sv
                JOIN PROPOSITIONS p on p.idProposition=sv.idProposition AND archive='V' WHERE sv.idPhaseVote=p_idPhase;
                UPDATE PROPOSITIONS p1 SET archive='F' WHERE idProposition IN (SELECT p.idProposition FROM PROPOSITIONS p JOIN SESSIONVOTE sv ON sv.idProposition=p.idProposition WHERE score=v_scoreMax AND p1.idProposition=p.idProposition);
                v_nbMax := v_nbMax-1;
            END LOOP;
        ELSE
            -- déroulement dépouillement si c'est un jugement majoritaire
            DBMS_OUTPUT.PUT_LINE('je m''occupe du jugement majoritaire');
            -- le nombre total de proposition pour la session de vote sera décrémenté pour savoir quand on aura éliminer assez de proposition
            SELECT count(idProposition) INTO v_nbPropalRestant
            FROM SESSIONVOTE s
            WHERE IDPHASEVOTE = p_idPhase;
        
            -- nombre total de participant pour le vote, servira à calculer la médiane
            SELECT count(DISTINCT idVotant) INTO v_nbVotantTotal
            FROM VOTANTPROPOSITION v
            WHERE v.IDPHASEVOTE=p_idPhase;
        
            v_median := FLOOR(v_nbVotantTotal/2);
            DBMS_OUTPUT.PUT_LINE('localisation de la médiane: ' || v_median);
        
            IF v_nbPropalRestant > v_nbMax THEN -- contourner le cas où il y aurait mois ne propositions que de place restantes dès le début et que l'algo cherche a gérer une égalité
                v_currentScore := 0;
                WHILE v_nbPropalRestant > v_nbMax LOOP
                    -- archiver les propositions qui ne passent pas
                    FOR proposition IN curs_proposition LOOP
                        DBMS_OUTPUT.PUT_LINE('proposition n°' || proposition.idProposition);
                        
                        -- on stock le score médian de la proposition
                        SELECT scoreVote INTO v_scoreProp
                        FROM VOTANTPROPOSITION v
                        WHERE v.IDPHASEVOTE = p_idPhase AND v.IDPROPOSITION = proposition.idProposition AND ROWNUM = v_median
                        ORDER BY scoreVote;
                    IF(v_scoreProp = v_currentScore) THEN
                            DBMS_OUTPUT.PUT_LINE('la proposition n°' || proposition.idProposition || ' a été archivée');
                            UPDATE PROPOSITIONS P
                            SET ARCHIVE = 'V'
                            WHERE IDPROPOSITION = proposition.idProposition AND v_scoreProp = v_currentScore;
                            v_nbPropalRestant := v_nbPropalRestant-1;
                        END IF;
                    END LOOP;
                    v_currentScore := v_currentScore + 1;
                END LOOP;
            
                -- départager quand il y a une égalité, implémentation partielle
                IF v_nbPropalRestant < v_nbMax THEN
                    v_increment := 1; -- simulera l'offset de l'INDEX médian comme si ON enlevait le vote median a chaque fois
                    v_direction := -1;
                    v_scorePrecedant := v_currentScore;
                    WHILE v_nbPropalRestant < v_nbMax LOOP
                        FOR proposition IN curs_propositionScore(v_currentScore) LOOP
                            SELECT scoreVote INTO v_scoreProp
                            FROM VOTANTPROPOSITION v
                            WHERE v.IDPHASEVOTE = p_idPhase AND v.IDPROPOSITION = proposition.idProposition AND ROWNUM = v_median + v_increment*v_direction
                            ORDER BY scoreVote;
                            IF (v_scoreProp != v_currentScore) THEN
                                IF (v_currentScore != v_scorePrecedant AND v_scoreProp > v_scorePrecedant) THEN
                                    UPDATE PROPOSITIONS SET ARCHIVE='F' WHERE idProposition=proposition.idProposition;
                                    v_nbPropalRestant := v_nbPropalRestant+1;
                                END IF;
                            END IF;
                        END LOOP;
                        IF v_direction = -1 THEN
                            v_direction := 1;
                        ELSE
                            v_direction := -1;
                            v_increment := v_increment + 1;
                        END IF;
                    END LOOP;
                END IF;
            
            END IF;
        
            -- générer les scores des propositions en leur mettant le score médian comme score final
            FOR proposition IN curs_proposition LOOP
                SELECT scoreVote INTO v_scoreProp
                FROM VOTANTPROPOSITION v
                WHERE v.IDPHASEVOTE = p_idPhase AND v.IDPROPOSITION = proposition.idProposition AND ROWNUM = v_median;
                
                UPDATE SESSIONVOTE 
                SET SCORE = v_scoreProp
                WHERE IDPROPOSITION = proposition.idProposition;
            END LOOP;       
        END IF;
    END IF;

    UPDATE PHASES SET dateFIN=SYSDATE WHERE idPhase = p_idPhase;
END;

CREATE OR REPLACE PROCEDURE SOUVIGNETN.sauvegarderDemande(p_typeDemande VARCHAR2, p_idDemandeur IN USERS."idUser"%TYPE, p_idQuestion IN QUESTIONS.IDQUESTION%TYPE, p_idProposition IN PROPOSITIONS.IDPROPOSITION%TYPE)
IS
    v_verif INTEGER;
BEGIN
    IF(p_typeDemande='votant') THEN
        SELECT COUNT(idQuestion) INTO v_verif
        FROM DemandeVotant WHERE idUser=p_idDemandeur AND idQuestion=p_idQuestion;
        IF(v_verif=0) THEN
            INSERT INTO DEMANDEVOTANT(idUser, idQuestion) VALUES(p_idDemandeur, p_idQuestion);
        END IF;
    ELSIF(p_typeDemande='auteur') THEN
        INSERT INTO DEMANDEAUTEUR(idUser, idProposition)
        VALUES(p_idDemandeur, p_idProposition);
    ELSIF(p_typeDemande='responsable') THEN
        INSERT INTO DEMANDERESPONSABLE(idUser, idQuestion)
        VALUES(p_idDemandeur, p_idQuestion);
    ELSE
        DBMS_OUTPUT.PUT_LINE('la demande n''a pas été prise en compte');
    END IF;
END;

CREATE OR REPLACE PROCEDURE SOUVIGNETN.setRoleAuteur(p_idUser IN USERS."idUser"%TYPE, p_idProposition IN Propositions.IDPROPOSITION%TYPE, p_idQuestion IN Questions.idQuestion%TYPE)
IS
BEGIN
    DELETE FROM VOTANTS v
    WHERE IDUSER=p_idUser
    AND idQuestion = p_idQuestion;
    INSERT INTO Votants(idUser, idQuestion) VALUES(p_idUser, p_idQuestion); 
    INSERT INTO AUTEURS(idVotant, idQuestion) VALUES (p_idUser, p_idQuestion);
    INSERT INTO AUTEURPROPOSITION(idAuteur, idQuestion, idProposition) VALUES (p_idUser, p_idQuestion, p_idProposition);
END;

CREATE OR REPLACE PROCEDURE SOUVIGNETN.setRolePropositionGroupe(p_idGroupe IN GroupeUsers.NOMGROUPE%TYPE, p_role VARCHAR2, p_idProposition IN PROPOSITIONS.IDPROPOSITION%TYPE)
IS
    CURSOR cursor_user IS
    SELECT idUser FROM appartientGroupe
    WHERE NOMGROUPE = p_idGroupe;
    v_idQuestion QUESTIONS.idQuestion%TYPE;
BEGIN
    SELECT idQuestion INTO v_idQuestion
    FROM PROPOSITIONS WHERE idProposition=p_idProposition;
    FOR idUser IN cursor_user LOOP
        setRoleQuestion(idUser.idUser, p_role, v_idQuestion);
        INSERT INTO AuteurProposition(idAuteur, idProposition, idQuestion) VALUES (idUser.idUser, p_idProposition, v_idQuestion);
    END LOOP;
END;

CREATE OR REPLACE PROCEDURE SOUVIGNETN.setRoleQuestion(p_idUser IN Votants.idUser%TYPE, p_role VARCHAR2, p_idQuestion IN Questions.IDQUESTION%TYPE)
IS
    -- assigner un role à un utilisateur pour une question donnée
    v_verif NUMBER;
    v_currentRole VARCHAR2(15);
BEGIN
    v_currentRole := getRoleQuestion(p_idUser, p_idQuestion);
    -- première fois que l'on assigne un role à l'utilisateur pour la question
    IF(v_currentRole IS NULL AND (p_role!='' OR p_role IS NOT NULL))THEN
        DBMS_OUTPUT.PUT_LINE('(setRole votant) idUser: ' || p_idUser || ' idQuestion: ' || p_idQuestion);
        INSERT INTO VOTANTS(idUser, idQuestion) VALUES(p_idUser, p_idQuestion);
        v_currentRole:='votant';
    END IF;
    if(v_currentRole!=p_role) THEN
        -- le role actuel est responsable
        IF(v_currentRole='responsable') THEN
            -- le nouveau role est auteur
            if(p_role='auteur') THEN
                DELETE FROM Responsables WHERE idAuteur=p_idUser AND idQuestion=p_idQuestion;
            ELSIF(p_role='votant') THEN
                DELETE FROM Auteurs WHERE idVotant=p_idUser AND idQuestion=p_idQuestion;
            ELSE
                DBMS_OUTPUT.PUT_LINE('1- je n''ai pas réussi à donner le nouveau rôle');
            END IF;
        ELSIF(v_currentRole='auteur') THEN
            IF(p_role='responsable')THEN
                INSERT INTO RESPONSABLES(idAuteur, idQuestion)
                VALUES(p_idUser, p_idQuestion);
            ELSIF(p_role='votant') THEN
                DELETE FROM Auteurs WHERE idVotant=p_idUser AND idQuestion=p_idQuestion;
            ELSE
                DBMS_OUTPUT.PUT_LINE('2- je n''ai pas réussi à donner le nouveau rôle');
            END IF;
        ELSIF(v_currentRole='votant') THEN
            IF(p_role='responsable' OR p_role='auteur')THEN
                INSERT INTO AUTEURS(idVotant, idQuestion)
                VALUES(p_idUser, p_idQuestion);
                IF(p_role='responsable') THEN
                    INSERT INTO RESPONSABLES(idAuteur, idQuestion)
                    VALUES(p_idUser, p_idQuestion);
                END IF;
            ELSE
                DBMS_OUTPUT.PUT_LINE('3- je n''ai pas réussi à donner le nouveau rôle');
            END IF;
        END IF;
    END IF;
END;

CREATE OR REPLACE PROCEDURE SOUVIGNETN.setRoleQuestionGroupe(p_idGroupe IN GroupeUsers.NOMGROUPE%TYPE, p_role VARCHAR2, p_idQuestion IN Questions.IDQUESTION%TYPE)
IS
    CURSOR cursor_user IS
    SELECT idUser FROM appartientGroupe
    WHERE NOMGROUPE = p_idGroupe;
BEGIN
    FOR idUser IN cursor_user LOOP
        setRoleQuestion(idUser.idUser, p_role, p_idQuestion);
    END LOOP;
END;

CREATE OR REPLACE procedure SOUVIGNETN.start_Phase(p_idPhase IN PHASES.idPhase%TYPE)
IS
    v_vote INTEGER;
    v_verif INTEGER;
    CURSOR curs_propositions IS SELECT p.idProposition, q.idQuestion
                                FROM PROPOSITIONS p
                                JOIN QUESTIONS q ON q.idQuestion = p.idQuestion
                                JOIN PHASES pv ON pv.idQuestionConcerne = q.idQuestion
                                WHERE pv.idPhase=p_idPhase;
    CURSOR curs_insertionJugeMajo IS
        SELECT idUser
        FROM VOTANTS v
        JOIN Phases p ON v.idQuestion=p.IDQUESTIONCONCERNE
        WHERE idPhase=p_idPhase;
    v_verifVotant INTEGER;
    v_typePhase VARCHAR2(30);
    v_idQuestion INTEGER;
BEGIN
    SELECT COUNT(IDPHASE) INTO v_vote FROM PHASESVOTE WHERE IDPHASE = p_idPhase;
    
    IF v_vote>0 THEN -- il s'agit d'une phase de vote
    
        SELECT typePhase INTO v_typePhase -- TYPE de la phase
        FROM PHASES p WHERE IDPHASE = p_idPhase;
        SELECT IDQUESTIONCONCERNE INTO v_idQuestion -- idQuestion de la phase
        FROM PHASES p WHERE p.IDPHASE = p_idPhase;
    
        FOR proposition IN curs_propositions LOOP
            
            SELECT COUNT(idProposition) INTO v_verif FROM SESSIONVOTE sv
            WHERE proposition.idProposition=sv.idProposition
            AND sv.idPhaseVote=p_idPhase;
        
            IF v_verif=0 THEN
                dbms_output.put_line('ca marche');
                -- on initialise la place dans la session de vote
                INSERT INTO SESSIONVOTE(idQuestion, IDPHASEVOTE, idProposition)
                        VALUES(proposition.idQuestion, p_idPhase, proposition.idProposition);
                
                -- permettra de calculer le total de participant
                IF v_typePhase='jugementMajoritaire' OR v_typePhase='scrutinMajoritairePlurinominal' THEN
                    FOR idUser IN curs_insertionJugeMajo LOOP
                        INSERT INTO VOTANTPROPOSITION(idVotant, idQuestion, IDPHASEVOTE, IDPROPOSITION, SCOREVOTE) 
                        VALUES(idUser.idUser, v_idQuestion, p_idPhase, proposition.idProposition, 0);   
                    END LOOP;
                END IF;
            ELSE
                dbms_output.put_line('ca marche pas' || v_verif);
            END IF;
        END LOOP;
            
    ELSE
        dbms_output.put_line('ce n''est pas une phase de vote');
    END IF;
    UPDATE PHASES SET dateDebut = SYSDATE WHERE idPhase=p_idPhase;
END;

CREATE OR REPLACE PROCEDURE SOUVIGNETN.updateAuteur(p_idAuteur IN AUTEURS.idVotant%TYPE, p_idProposition IN PROPOSITIONS.IDPROPOSITION%TYPE, p_idQuestion IN Questions.idQuestion%TYPE)
IS
    v_verif NUMBER;
BEGIN
    SELECT COUNT(idAuteur) INTO v_verif
    FROM AUTEURProposition
    WHERE idAuteur=p_idAuteur AND idProposition=p_idProposition;
    IF (v_verif=0) THEN
        SETROLEAUTEUR(p_idAuteur, p_idProposition, p_idQuestion);
    END IF;
END;

CREATE OR REPLACE procedure SOUVIGNETN.updatePhase
IS
    v_idCurrentPhase QUESTIONS.idCurrentPhase%TYPE;
    CURSOR curs_Questions IS
        SELECT idQuestion, idCurrentPhase
        FROM QUESTIONS;
BEGIN
    FOR question IN curs_Questions LOOP
        SELECT getIdPhase(question.idQuestion) INTO v_idCurrentPhase FROM DUAL;
        dbms_output.put_line('l''id: ' || v_idCurrentPhase || 'celui de la question: ' || question.idCurrentPhase);

        IF v_idCurrentPhase <> question.idCurrentPhase THEN
            end_Phase(question.idCurrentPhase);
            UPDATE QUESTIONS SET idCurrentPhase = v_idCurrentPhase WHERE idQuestion=question.idQuestion;
            start_Phase(v_idCurrentPhase);

        ELSIF v_idCurrentPhase IS NULL THEN
            IF question.idCurrentPhase IS NOT NULL THEN
                end_Phase(question.idCurrentPhase);
            END IF;
            UPDATE QUESTIONS SET idCurrentPhase = NULL WHERE idQuestion=question.idQuestion;

        ELSIF question.idCurrentPhase IS NULL AND v_idCurrentPhase IS NOT NULL THEN
            UPDATE QUESTIONS SET idCurrentPhase = v_idCurrentPhase WHERE idQuestion=question.idQuestion;
            start_Phase(v_idCurrentPhase);
        END IF;
    END LOOP;
    COMMIT;
END;

CREATE OR REPLACE procedure SOUVIGNETN.voter(p_idVotant IN VOTANTS.idUser%TYPE, p_idProposition IN PROPOSITIONS.idProposition%TYPE, p_scoreVote INTEGER)
IS
    v_typePhase PHASES.typePhase%TYPE;
    v_idPhase PHASESVOTE.idPhase%TYPE;
    v_idQuestion QUESTIONS.idQuestion%TYPE;
    v_verif INTEGER; -- vérifier si l'utilisateur peut voter
BEGIN
    SELECT idQuestion INTO v_idQuestion FROM Propositions p WHERE p.idProposition=p_idProposition;
    SELECT COUNT(idUser) INTO v_verif
    FROM VOTANTS v
    JOIN Propositions p ON p.idQuestion=v.idQuestion
    WHERE p_idProposition=p.idProposition;

    IF v_verif > 0 THEN
        SELECT idCurrentPhase INTO v_idPhase
        FROM QUESTIONS q
        WHERE idQuestion = v_idQuestion;

        SELECT typePhase INTO v_typePhase
        FROM PHASES
        WHERE idPhase=v_idPhase;

        IF v_typePhase = 'scrutinMajoritaire' THEN
            dbms_output.put_line(v_idPhase);
            SELECT COUNT(idVotant) INTO v_verif
            FROM VOTANTPROPOSITION vp
            WHERE vp.idVotant=p_idVotant AND vp.idPhaseVote=v_idPhase;
            IF v_verif=1 THEN -- le votant a déjà voté, on modifie alors son choix
                dbms_output.put_line('j update le score a ');
                UPDATE VOTANTPROPOSITION vp SET idProposition=p_idProposition
                WHERE idVotant=p_idVotant AND idPhaseVote = v_idPhase;
            ELSIF v_verif=0 THEN -- sinon on creer son vote
                dbms_output.put_line('j insert le score ');
                INSERT INTO VOTANTPROPOSITION(idVotant, idQuestion, idProposition, idPhaseVote, scoreVote)
                VALUES(p_idVotant, v_idQuestion, p_idProposition, v_idPhase, 1);
            END IF;
        ELSIF v_typePhase = 'scrutinMajoritairePlurinominal' THEN
            SELECT COUNT(idVotant) INTO v_verif
            FROM VOTANTPROPOSITION vp
            WHERE vp.idVotant=p_idVotant AND vp.idPhaseVote=v_idPhase AND vp.IDPROPOSITION = p_idProposition;
            IF v_verif=1 THEN
                UPDATE VOTANTPROPOSITION SET SCOREVOTE=p_scoreVote
                WHERE IDVOTANT=p_idVotant AND IDPROPOSITION=p_idProposition AND IDPHASEVOTE=v_idPhase;
            ELSE
                INSERT INTO VOTANTPROPOSITION(idVotant, idProposition, idPhaseVote, scoreVote)
                VALUES(p_idVotant, p_idProposition, v_idPhase, p_scoreVote);
            END IF;
        ELSIF v_typePhase = 'jugementMajoritaire' THEN
            DBMS_OUTPUT.PUT_LINE('vote pour jugement majoritaire : ' ||p_scoreVote);
            UPDATE VOTANTPROPOSITION SET SCOREVOTE=p_scoreVote
            WHERE IDVOTANT=p_idVotant AND IDPROPOSITION=p_idProposition AND IDPHASEVOTE=v_idPhase;
        ELSE
            DBMS_OUTPUT.PUT_LINE(v_typePhase ||' n''est pas une phase de vote');
        END IF;
    END IF;
END;

CREATE OR REPLACE FUNCTION SOUVIGNETN.GETIDPHASE(p_idQuestion IN QUESTIONS.idQuestion%TYPE) RETURN VARCHAR
IS
    v_phaseSet VARCHAR2(100);
    v_currentDate DATE;
BEGIN
    SELECT CURRENT_DATE INTO v_currentDate FROM DUAL;
    SELECT idPhase INTO v_phaseSet
    FROM phases
    WHERE IDQUESTIONCONCERNE = p_idQuestion
    AND DATEDEBUT <= v_currentDate 
    AND DATEFIN > v_currentDate;
    if(v_phaseSet is null) then
        return NULL;
    else
        return v_phaseSet;
    end if;
end;

CREATE OR REPLACE function SOUVIGNETN.getPhase(p_idQuestion IN QUESTIONS.idQuestion%TYPE) RETURN PHASES%ROWTYPE
IS
    v_currentDate DATE;
    v_phase PHASES%ROWTYPE;
BEGIN
    SELECT SYSDATE INTO v_currentDate FROM DUAL;
    SELECT * INTO v_phase FROM PHASES
    WHERE IDQUESTIONCONCERNE = p_idQuestion
    AND dateDebut<=SYSDATE AND dateFin>SYSDATE;
    return v_phase;
END;

CREATE OR REPLACE FUNCTION SOUVIGNETN.getRoleProposition(p_idUser IN USERS."idUser"%TYPE, p_idProposition IN PROPOSITIONS.IDPROPOSITION%TYPE) RETURN VARCHAR2
IS
    v_role VARCHAR2(15);
    v_verif NUMBER;
BEGIN
    v_role:='';
    SELECT COUNT(idAuteur) INTO v_verif
    FROM AUTEURPROPOSITION
    WHERE idAuteur=p_idUser AND idProposition=p_idProposition;
    IF(v_verif>0) THEN
        SELECT COUNT(idResponsable) INTO v_verif
        FROM PROPOSITIONS
        WHERE idResponsable=p_idUser AND idProposition=p_idProposition;
        IF(v_verif>0) THEN
            v_role:='responsable';
        ELSE
            v_role:='auteur';
        END IF;
    END IF;
END;

CREATE OR REPLACE FUNCTION SOUVIGNETN.getRoleQuestion(p_idUser IN VOTANTS.IDUSER%TYPE, p_idQuestion IN QUESTIONS.IDQUESTION%TYPE) RETURN VARCHAR2
IS
    v_verif NUMBER;
BEGIN
    SELECT COUNT(v.idUser) INTO v_verif
    FROM VOTANTS v WHERE v.IDUSER = p_idUser AND v.IDQUESTION = p_idQuestion;
    if(v_verif > 0) THEN
        SELECT count(q.idOrganisateur) INTO v_verif
        FROM Questions q WHERE q.idQuestion=p_idQuestion AND q.idOrganisateur=p_idUser;
        if(v_verif>0) THEN 
            RETURN 'organisateur';
        ELSE
            SELECT count(idVotant) INTO v_verif
            FROM AUTEURS a
            WHERE idVotant=p_idUser AND idQuestion=p_idQuestion;
            IF(v_verif>0) THEN
                SELECT COUNT(idAuteur) INTO v_verif
                FROM RESPONSABLES
                WHERE idAuteur=p_idUser AND idQuestion=p_idQuestion;
                IF(v_verif>0) THEN
                    RETURN 'responsable';
                ELSE
                    RETURN 'auteur';
                END IF;
            ELSE
                RETURN 'votant';
            END IF;
        END IF;
    ELSE
        RETURN null;
    END IF;
END;

CREATE OR REPLACE FUNCTION SOUVIGNETN.is_phase_finished(p_idPhase IN Phases.IDPHASE%TYPE) RETURN NUMBER
-- retourne 1 si la phase est finie, 0 sinon
IS
    v_verif NUMBER;
BEGIN
    SELECT count(idPhase) INTO v_verif
    FROM phases
    WHERE idPhase = p_idPhase AND DATEFIN<=SYSDATE;
    RETURN v_verif;
END;

CREATE OR REPLACE function SOUVIGNETN.peutVoter(p_idVotant IN VOTANTS.idUser%TYPE, p_idQuestion IN QUESTIONS.idQuestion%TYPE) RETURN INTEGER
IS
    v_verif INTEGER;
BEGIN
    SELECT COUNT(idUser) INTO v_verif
    FROM VOTANTS WHERE idUser=p_idVotant AND idQuestion=p_idQuestion;
    RETURN v_verif;
END;
